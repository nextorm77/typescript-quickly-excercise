{"version":3,"file":"blockchain-node.js","sourceRoot":"","sources":["../../../src/client/lib/blockchain-node.ts"],"names":[],"mappings":"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","sourcesContent":["import { sha256 } from './cryptography.js';\nimport { randomDelay } from '../ui/common.js';\n\nconst HASH_REQUIREMENT = '0000';\n\nexport interface Transaction {\n  readonly sender: string;\n  readonly recipient: string;\n  readonly amount: number;\n}\n\nexport interface Block {\n  readonly hash: string;\n  readonly nonce: number;\n  readonly previousHash: string;\n  readonly timestamp: number;\n  readonly transactions: Transaction[];\n}\n\nexport type WithoutHash<T> = Omit<T, 'hash'>;\nexport type NotMinedBlock = Omit<Block, 'hash' | 'nonce'>;\n\nexport class BlockchainNode {\n  private _chain: Block[] = [];\n  private _pendingTransactions: Transaction[] = [];\n  private _isMining = false;\n\n  initializeWith(blocks: Block[]): void {\n    this._chain = [...blocks ];\n  }\n\n  async initializeWithGenesisBlock(): Promise<void> {\n    const genesisBlock = await this.mineBlock({ previousHash: '0', timestamp: Date.now(), transactions: [] });\n    this._chain.push(genesisBlock);\n  }\n\n  async mineBlock(block: NotMinedBlock): Promise<Block> {\n    this._isMining = true;\n    let hash = '';\n    let nonce = 0;\n\n    do {\n      hash = await this.calculateHash({ ...block, nonce: ++nonce })\n    } while (!hash.startsWith(HASH_REQUIREMENT));\n\n    this._isMining = false;\n    this._pendingTransactions = [];\n    return { ...block, hash, nonce };\n  }\n\n  async mineBlockWith(transactions: Transaction[]): Promise<Block> {\n    // NOTE: INTRODUCING A RANDOM DELAY FOR DEMO PURPOSES.\n    // We want to randomize block's timestamp creation so the node that generates transactions\n    // doesn't have an advantage since it's timestamp will always be earlier.\n    await randomDelay(500);\n\n    const block = { previousHash: this.latestBlock.hash, timestamp: Date.now(), transactions };\n    return this.mineBlock(block);\n  }\n\n  get isMining(): boolean {\n    return this._isMining;\n  }\n\n  get chain(): Block[] {\n    return [ ...this._chain ];\n  }\n\n  get chainIsEmpty(): boolean {\n    return this._chain.length === 0;\n  }\n\n  get latestBlock(): Block {\n    return this._chain[this._chain.length - 1];\n  }\n\n  get pendingTransactions(): Transaction[] {\n    return [ ...this._pendingTransactions ];\n  }\n\n  get hasPendingTransactions(): boolean {\n    return this.pendingTransactions.length > 0;\n  }\n\n  get noPendingTransactions(): boolean {\n    return this.pendingTransactions.length === 0;\n  }\n\n  addTransaction(transaction: Transaction): void {\n    this._pendingTransactions.push(transaction);\n  }\n\n  /**\n   * Attempts to add a block into the blockchain. The rejected promise carries the reason why the block wasn't added.\n   */\n  async addBlock(newBlock: Block): Promise<void> {\n    const errorMessagePrefix = `⚠️ Block \"${newBlock.hash.substr(0, 8)}\" is rejected`;\n\n    // Find the block after which the new block should be added.\n    const previousBlockIndex = this._chain.findIndex(b => b.hash === newBlock.previousHash);\n    if (previousBlockIndex < 0) {\n      throw new Error(`${errorMessagePrefix} - there is no block in the chain with the specified previous hash \"${newBlock.previousHash.substr(0, 8)}\".`);\n    }\n\n    // The current node may already have one or more blocks generated (or received from other nodes in the network),\n    // after the one we attempt to add. In this case the longest chain takes precedence and the new block is rejected.\n    const tail = this._chain.slice(previousBlockIndex + 1);\n    if (tail.length >= 1) {\n      throw new Error(`${errorMessagePrefix} - the longer tail of the current node takes precedence over the new block.`);\n    }\n\n    // Verify the hash of the new block against the hash of the previous block.\n    const newBlockHash = await this.calculateHash(newBlock);\n    const prevBlockHash = this._chain[previousBlockIndex].hash;\n    const newBlockValid = (\n      newBlockHash.startsWith(HASH_REQUIREMENT) &&\n      newBlock.previousHash === prevBlockHash &&\n      newBlock.hash === newBlockHash\n    );\n    if (!newBlockValid) {\n      throw new Error(`${errorMessagePrefix} - hash verification has failed.`);\n    }\n\n    // Append the new block at the end of the chain.\n    this._chain = [ ...this._chain, newBlock ];\n  }\n\n  private async calculateHash(block: WithoutHash<Block>): Promise<string> {\n    const data = block.previousHash + block.timestamp + JSON.stringify(block.transactions) + block.nonce;\n    return sha256(data);\n  }\n}\n"]}